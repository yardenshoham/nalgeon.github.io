<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>All posts on Anton Zhiyanov</title><link>https://antonz.org/posts/</link><description>Recent content in All posts on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 22 Jan 2023 18:00:00 +0000</lastBuildDate><atom:link href="https://antonz.org/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>SQL Window Functions Explained</title><link>https://antonz.org/sql-window-functions-book/</link><pubDate>Sun, 22 Jan 2023 18:00:00 +0000</pubDate><guid>https://antonz.org/sql-window-functions-book/</guid><description>Window functions are probably the most confusing section of SQL. You might think, &amp;ldquo;So what? They just came up with some additional functions&amp;rdquo;. Not really. &amp;ldquo;Window functions&amp;rdquo; is a separate language built into regular SQL. And it&amp;rsquo;s more complicated than everything you know about SELECTs.
In short, window functions assist in making great analytical reports without Excel. Maybe you want to calculate monthly sales percentages over the year? Window functions. Split marketing channels into effective and ineffective ones?</description></item><item><title>Atomic operations composition in Go</title><link>https://antonz.org/atomics-composition/</link><pubDate>Tue, 17 Jan 2023 09:20:00 +0000</pubDate><guid>https://antonz.org/atomics-composition/</guid><description>An atomic operation in a concurrent program is a great thing. Such operation transforms into a single processor instruction, so it does not require locks. You can safely call it from different goroutines and receive a predictable result.
But what happens if you misuse atomics? Let&amp;rsquo;s figure it out.
Atomicity Let&amp;rsquo;s look at a function that increments a counter:
var counter int32 func increment() { counter += 1 // random sleep up to 10 ms sleep(10) counter += 1 } If we call it 100 times in a single goroutine:</description></item><item><title>Idempotent Close in Go</title><link>https://antonz.org/idempotent-close/</link><pubDate>Wed, 11 Jan 2023 11:00:00 +0000</pubDate><guid>https://antonz.org/idempotent-close/</guid><description>Idempotence is when a repeated call to an operation on an object does not result in changes or errors. Idempotence is a handy development tool.
Let&amp;rsquo;s see how idempotence helps to free the occupied resources safely.
Idempotent Close Suppose we have a gate:
type Gate struct{ // internal state // ... } The NewGate() constructor opens the gate, acquires some system resources, and returns an instance of the Gate.</description></item><item><title>Speed of algorithms (with cats)</title><link>https://antonz.org/big-o/</link><pubDate>Wed, 21 Dec 2022 16:50:00 +0000</pubDate><guid>https://antonz.org/big-o/</guid><description>Let&amp;rsquo;s see how programmers evaluate fast and slow algorithms. Since the topic is pretty boring, we&amp;rsquo;ll use silly cat examples.
Constant time: O(1) This is your best option. The algorithm speed does not depend on the number of cats.
🐾 Example
You are the lucky owner of N cats. Every kitten knows their name. If you call "Felix!", only one will come running, and the rest of the N-1 fluffs don't care.</description></item><item><title>User-defined functions in SQLite</title><link>https://antonz.org/sqlean-define/</link><pubDate>Thu, 08 Sep 2022 15:30:00 +0000</pubDate><guid>https://antonz.org/sqlean-define/</guid><description>Write functions in plain SQL using the &amp;lsquo;define&amp;rsquo; extension.
SQLite does not directly support user-defined functions. Sure, one can write a function in C or Python and register it within SQLite. But not in SQL itself.
Luckily for us, SQLite provides an extension mechanism. One of such extensions — define — allows writing functions in regular SQL.
With define writing a custom function becomes as easy as:
select define(&amp;#39;sumn&amp;#39;, &amp;#39;:n * (:n + 1) / 2&amp;#39;); And then using it as any built-in function:</description></item><item><title>JSON Lines</title><link>https://antonz.org/json-lines/</link><pubDate>Thu, 04 Aug 2022 18:30:00 +0000</pubDate><guid>https://antonz.org/json-lines/</guid><description>Worked with the JSON Lines format the other day. It&amp;rsquo;s a CSV on steroids:
each entry is a separate line, as in CSV; at the same time it is a full-fledged JSON. For example:
{ &amp;#34;id&amp;#34;:11, &amp;#34;name&amp;#34;:&amp;#34;Diane&amp;#34;, &amp;#34;city&amp;#34;:&amp;#34;London&amp;#34;, &amp;#34;department&amp;#34;:&amp;#34;hr&amp;#34;, &amp;#34;salary&amp;#34;:70 } { &amp;#34;id&amp;#34;:12, &amp;#34;name&amp;#34;:&amp;#34;Bob&amp;#34;, &amp;#34;city&amp;#34;:&amp;#34;London&amp;#34;, &amp;#34;department&amp;#34;:&amp;#34;hr&amp;#34;, &amp;#34;salary&amp;#34;:78 } { &amp;#34;id&amp;#34;:21, &amp;#34;name&amp;#34;:&amp;#34;Emma&amp;#34;, &amp;#34;city&amp;#34;:&amp;#34;London&amp;#34;, &amp;#34;department&amp;#34;:&amp;#34;it&amp;#34;, &amp;#34;salary&amp;#34;:84 } { &amp;#34;id&amp;#34;:22, &amp;#34;name&amp;#34;:&amp;#34;Grace&amp;#34;, &amp;#34;city&amp;#34;:&amp;#34;Berlin&amp;#34;, &amp;#34;department&amp;#34;:&amp;#34;it&amp;#34;, &amp;#34;salary&amp;#34;:90} { &amp;#34;id&amp;#34;:23, &amp;#34;name&amp;#34;:&amp;#34;Henry&amp;#34;, &amp;#34;city&amp;#34;:&amp;#34;London&amp;#34;, &amp;#34;department&amp;#34;:&amp;#34;it&amp;#34;, &amp;#34;salary&amp;#34;:104} Great stuff:</description></item><item><title>Expressive Ellipsis in Python</title><link>https://antonz.org/ellipsis/</link><pubDate>Fri, 03 Jun 2022 10:50:00 +0000</pubDate><guid>https://antonz.org/ellipsis/</guid><description>One of the lesser-known things in Python is the ellipsis:
class Flyer: def fly(self): ... This code works. The ... (aka Ellipsis) is a real object that can be used in code.
Ellipsis is the only instance of the EllipsisType type (similar to how None is the only instance of the NoneType type):
&amp;gt;&amp;gt;&amp;gt; ... is Ellipsis &amp;gt;&amp;gt;&amp;gt; True &amp;gt;&amp;gt;&amp;gt; Ellipsis is ... &amp;gt;&amp;gt;&amp;gt; True Python core devs mostly use .</description></item><item><title>Flying Pig, or Protocols in Python</title><link>https://antonz.org/protocol/</link><pubDate>Tue, 31 May 2022 17:00:00 +0000</pubDate><guid>https://antonz.org/protocol/</guid><description>Let&amp;rsquo;s say you&amp;rsquo;ve developed a utility that sends everything flying:
def launch(thing): thing.fly() Well, not exactly everything. Things with the fly() method, to be precise. With a single handy function we launch Frank (he&amp;rsquo;s a pigeon), an airplane, and even Superman:
class Frank: def fly(self): print(&amp;#34;💩&amp;#34;) class Plane: def fly(self): print(&amp;#34;Flight delayed&amp;#34;) class Superman: def fly(self): print(&amp;#34;ε===(っ≧ω≦)っ&amp;#34;) Whoosh:
f = Frank() launch(f) # 💩 p = Plane() launch(p) # Flight delayed s = Superman() launch(s) # ε===(っ≧ω≦)っ It&amp;rsquo;s not that our heroes are particularly successful at coping with the task, but the launch works for them.</description></item><item><title>Random numbers and sequences in Python</title><link>https://antonz.org/random/</link><pubDate>Mon, 23 May 2022 15:30:00 +0000</pubDate><guid>https://antonz.org/random/</guid><description>Everybody knows about random.randint(a, b) in Python, which returns a ≤ n ≤ b:
random.randint(10, 99) # 59 But the random module has so much more to offer.
Like selecting a number from a range with a step:
random.randrange(10, 99, 3) # 91 Or a random sequence element:
numbers = [7, 9, 13, 42, 64, 99] random.choice(numbers) # 42 Or multiple elements:
numbers = range(99, 10, -1) random.choices(numbers, k=3) # [32, 62, 76] How about choosing some elements more often than others?</description></item><item><title>Common Table Expressions in SQL</title><link>https://antonz.org/cte/</link><pubDate>Fri, 20 May 2022 16:50:00 +0000</pubDate><guid>https://antonz.org/cte/</guid><description>Rule #1 for writing well-readable SQL queries is to use common table expressions (CTE). People are afraid of them, but they really shouldn&amp;rsquo;t. Let&amp;rsquo;s learn CTEs in three minutes, so you don&amp;rsquo;t have to read a weighty SQL book or take an online course.
Problem Let&amp;rsquo;s say we have a table with monthly sales for two years:
┌──────┬───────┬───────┬──────────┬─────────┐ │ year │ month │ price │ quantity │ revenue │ ├──────┼───────┼───────┼──────────┼─────────┤ │ 2019 │ 1 │ 60 │ 200 │ 12000 │ │ 2019 │ 2 │ 60 │ 660 │ 39600 │ │ 2019 │ 3 │ 60 │ 400 │ 24000 │ │ 2019 │ 4 │ 60 │ 300 │ 18000 │ │ 2019 │ 5 │ 60 │ 440 │ 26400 │ │ 2019 │ 6 │ 60 │ 540 │ 32400 │ │ 2019 │ 7 │ 60 │ 440 │ 26400 │ │ 2019 │ 8 │ 60 │ 440 │ 26400 │ │ 2019 │ 9 │ 60 │ 250 │ 15000 │ │ 2019 │ 10 │ 60 │ 420 │ 25200 │ │ .</description></item></channel></rss>