<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>All posts on Anton Zhiyanov</title><link>https://antonz.org/posts/</link><description>Recent content in All posts on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 07 Jun 2023 14:00:00 +0000</lastBuildDate><atom:link href="https://antonz.org/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>More String Functions in SQLite</title><link>https://antonz.org/sqlean-text/</link><pubDate>Wed, 07 Jun 2023 14:00:00 +0000</pubDate><guid>https://antonz.org/sqlean-text/</guid><description>SQLite includes basic text functions like instr, substr and replace (and even trim in later versions), which can get you quite far. But I&amp;rsquo;ve always wanted a more complete set, like the one in PostgreSQL, Python or Go.
So I&amp;rsquo;ve created a sqlean-text extension that provides a rich set of string functions, from slice, contains and count to split_part, translate and repeat.
Note. Unlike other DBMS, adding extensions to SQLite is a breeze.</description></item><item><title>SQL Recipe: Compare with Neighbors</title><link>https://antonz.org/sql-compare-neighbors/</link><pubDate>Sat, 03 Jun 2023 15:00:00 +0000</pubDate><guid>https://antonz.org/sql-compare-neighbors/</guid><description>This post is part of the &amp;ldquo;SQL Recipes&amp;rdquo; series, where I provide short patterns for solving common SQL data analysis tasks.
Suppose we want to compare each data record with its neighbors based on some column value. For example:
Compare sales from one month to the previous month (month-over-month or MoM change) or to the same month a year ago (year-over-year or YoY change). Compare financial results for a given period to the same period in the previous year (like-for-like or LFL analysis).</description></item><item><title>Base64 and other encodings in SQLite</title><link>https://antonz.org/sqlean-encode/</link><pubDate>Thu, 01 Jun 2023 18:30:00 +0000</pubDate><guid>https://antonz.org/sqlean-encode/</guid><description>You&amp;rsquo;ve probably heard about hexadecimal encoding in SQLite:
select hex(&amp;#39;hello&amp;#39;); -- 68656C6C6F select unhex(&amp;#39;68656C6C6F&amp;#39;); -- hello SQLite does not support other encoding algorithms by default. However, you can easily enable them using the sqlean-crypto extension (not related to cryptocurrency in any way).
Note. Unlike other DBMS, adding extensions to SQLite is a breeze. Download a file, run one database command — and you are good to go.
sqlean-crypto adds two functions:</description></item><item><title>LIMIT vs. FETCH in SQL</title><link>https://antonz.org/sql-fetch/</link><pubDate>Tue, 30 May 2023 18:00:00 +0000</pubDate><guid>https://antonz.org/sql-fetch/</guid><description>Fun fact: There is no limit clause in the SQL standard.
Everyone uses limit:
select * from employees order by salary desc limit 5; ┌────┬───────┬────────────┬────────┐ │ id │ name │ department │ salary │ ├────┼───────┼────────────┼────────┤ │ 25 │ Frank │ it │ 120 │ │ 23 │ Henry │ it │ 104 │ │ 24 │ Irene │ it │ 104 │ │ 33 │ Alice │ sales │ 100 │ │ 31 │ Cindy │ sales │ 96 │ └────┴───────┴────────────┴────────┘ And yet, according to the standard, we should be using fetch:</description></item><item><title>SQL Recipe: Segmenting Data</title><link>https://antonz.org/sql-segmenting/</link><pubDate>Tue, 23 May 2023 15:30:00 +0000</pubDate><guid>https://antonz.org/sql-segmenting/</guid><description>This post is part of the &amp;ldquo;SQL Recipes&amp;rdquo; series, where I provide short patterns for solving common SQL data analysis tasks.
Suppose we want to divide our data into several segments based on the value of one or more columns (e.g., to assign customers or products to different groups for marketing purposes).
The solution is to use the ntile() function over an SQL window ordered by target columns.
Example Let&amp;rsquo;s divide the employees into three groups according to their salary:</description></item><item><title>SQL Cheat Sheet</title><link>https://antonz.org/sql-cheatsheet/</link><pubDate>Sun, 14 May 2023 13:00:00 +0000</pubDate><guid>https://antonz.org/sql-cheatsheet/</guid><description>This is a short cheat sheet for those who were once familiar with SQL selects, but haven&amp;rsquo;t given it much practice since. The examples are interactive, so you can both read and practice.
We will use the toy employees table:
┌────┬───────┬────────┬────────────┬────────┐ │ id │ name │ city │ department │ salary │ ├────┼───────┼────────┼────────────┼────────┤ │ 11 │ Diane │ London │ hr │ 70 │ │ 12 │ Bob │ London │ hr │ 78 │ │ 21 │ Emma │ London │ it │ 84 │ │ 22 │ Grace │ Berlin │ it │ 90 │ │ 23 │ Henry │ London │ it │ 104 │ │ 24 │ Irene │ Berlin │ it │ 104 │ │ 25 │ Frank │ Berlin │ it │ 120 │ │ 31 │ Cindy │ Berlin │ sales │ 96 │ │ 32 │ Dave │ London │ sales │ 96 │ │ 33 │ Alice │ Berlin │ sales │ 100 │ └────┴───────┴────────┴────────────┴────────┘ Basics The basic building blocks of an SQL query.</description></item><item><title>SQL Recipe: Ranking Records</title><link>https://antonz.org/sql-ranking/</link><pubDate>Thu, 11 May 2023 15:50:00 +0000</pubDate><guid>https://antonz.org/sql-ranking/</guid><description>This post is part of the &amp;ldquo;SQL Recipes&amp;rdquo; series, where I provide short patterns for solving common SQL data analysis tasks.
Suppose we want to create a ranking, where the position of each record is determined by the value of one or more columns.
The solution is to use the rank() function over an SQL window ordered by target columns.
Example Let&amp;rsquo;s rank employees by salary:
select rank() over w as &amp;#34;rank&amp;#34;, name, department, salary from employees window w as (order by salary desc) order by &amp;#34;rank&amp;#34;, id; The rank() function assigns each employee a rank according to their salary (order by salary desc).</description></item><item><title>Rolling Aggregates with SQL Window Functions</title><link>https://antonz.org/sql-window-functions-rolling-aggregates/</link><pubDate>Mon, 01 May 2023 12:00:00 +0000</pubDate><guid>https://antonz.org/sql-window-functions-rolling-aggregates/</guid><description>This is an excerpt from my book SQL Window Functions Explained. The book is a clear and visual introduction to the topic with lots of practical exercises.
Previously we&amp;rsquo;ve covered ranking, offset and aggregate window functions.
​Rolling aggregates (also known as sliding or moving aggregates) are just totals — sum, average, count etc. But instead of calculating them across all elements, we take a different approach.
Let&amp;rsquo;s look at some examples.</description></item><item><title>Aggregating Data with SQL Window Functions</title><link>https://antonz.org/sql-window-functions-aggregation/</link><pubDate>Sun, 30 Apr 2023 18:30:00 +0000</pubDate><guid>https://antonz.org/sql-window-functions-aggregation/</guid><description>This is an excerpt from my book SQL Window Functions Explained. The book is a clear and visual introduction to the topic with lots of practical exercises.
Previously we&amp;rsquo;ve covered ranking and offset window functions.
Aggregation means counting totals or averages (or other aggregates). For example, the average salary per city. Or the total number of gold medals for each country in the Olympic Games standings.
We will aggregate records from the employees table:</description></item><item><title>AI SQLite Assistant</title><link>https://antonz.org/sqlime-ai/</link><pubDate>Thu, 16 Mar 2023 12:00:00 +0000</pubDate><guid>https://antonz.org/sqlime-ai/</guid><description>While trying to trick AI into saying ethically questionable things may be fun for some of us, I prefer more practical and useful scenarios.
So, as of today, Sqlime — an online SQLite playground — includes the &amp;ldquo;Ask AI&amp;rdquo; feature.
AI can explain, teach, and troubleshoot your SQL without leaving the playground:
Write a question as a comment above the query. Click &amp;ldquo;Ask AI&amp;rdquo;. Receive a not-so-fast, but often useful answer from AI.</description></item></channel></rss>