<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>All posts on Anton Zhiyanov</title><link>https://antonz.org/posts/</link><description>Recent content in All posts on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 17 Jun 2023 04:00:00 +0000</lastBuildDate><atom:link href="https://antonz.org/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>I Don't Need Your Query Language</title><link>https://antonz.org/fancy-ql/</link><pubDate>Sat, 17 Jun 2023 04:00:00 +0000</pubDate><guid>https://antonz.org/fancy-ql/</guid><description>This post may seem a bit harsh, but I&amp;rsquo;m tired of the &amp;ldquo;SQL shaming&amp;rdquo; that has somehow become a thing in the industry. I have a right to disagree, don&amp;rsquo;t I?
Every year or so, a new general-purpose database engine comes out. And that&amp;rsquo;s great! It can bring new valuable approaches, architectures, and tools (plus, building database engines is fun).
Often this new database engine comes with a new query language.</description></item><item><title>Python's sqlite3 with extensions</title><link>https://antonz.org/sqlean-py/</link><pubDate>Thu, 15 Jun 2023 21:30:00 +0000</pubDate><guid>https://antonz.org/sqlean-py/</guid><description>Adding SQLite extensions with Python&amp;rsquo;s sqlite3 module is a breeze. Download a file, call a few functions, and you are good to go. Unless you try to do it on macOS, where sqlite3 is compiled without extension support.
I wanted to make the process even easier (and of course solve the macOS problem). So I created the sqlean.py package: a drop-in replacement for the standard library&amp;rsquo;s sqlite3 module, bundled with the essential extensions.</description></item><item><title>Covering Index in SQL</title><link>https://antonz.org/sql-covering-index/</link><pubDate>Mon, 12 Jun 2023 14:30:00 +0000</pubDate><guid>https://antonz.org/sql-covering-index/</guid><description>A covering index is the fastest way to select data from a table.
Let&amp;rsquo;s see how it works using a query that selects employees with a certain salary:
select id, name from employees where salary = 90; No index vs. Using an index If there is no index, the database engine goes through the entire table (this is called a &amp;ldquo;full scan&amp;rdquo;):
QUERY PLAN `--SCAN employees Let&amp;rsquo;s create an index by salary:</description></item><item><title>Blogging Myths You Should Care About</title><link>https://antonz.org/blogging-myths/</link><pubDate>Fri, 09 Jun 2023 12:00:00 +0000</pubDate><guid>https://antonz.org/blogging-myths/</guid><description>Okay, here are some REAL blogging myths:
People will actually read your blog. You&amp;rsquo;ll reach your target audience. You&amp;rsquo;ll have meaningful conversations. Your blog will help you get a job. In all cases, the answer is NO.
If you want to blog just because you like writing, that&amp;rsquo;s a great option. But blogging is not about popularity. There are exceptions, of course, like Julia Evans. But your chances of gaining that kind of audience are close to zero.</description></item><item><title>More String Functions in SQLite</title><link>https://antonz.org/sqlean-text/</link><pubDate>Wed, 07 Jun 2023 14:00:00 +0000</pubDate><guid>https://antonz.org/sqlean-text/</guid><description>SQLite includes basic text functions like instr, substr and replace (and even trim in later versions), which can get you quite far. But I&amp;rsquo;ve always wanted a more complete set, like the one in PostgreSQL, Python or Go.
So I&amp;rsquo;ve created a sqlean-text extension that provides 25 string functions, from slice, contains and count to split_part, translate and repeat.
Note. Unlike other DBMS, adding extensions to SQLite is a breeze.</description></item><item><title>SQL Recipe: Compare with Neighbors</title><link>https://antonz.org/sql-compare-neighbors/</link><pubDate>Sat, 03 Jun 2023 15:00:00 +0000</pubDate><guid>https://antonz.org/sql-compare-neighbors/</guid><description>This post is part of the &amp;ldquo;SQL Recipes&amp;rdquo; series, where I provide short patterns for solving common SQL data analysis tasks.
Suppose we want to compare each data record with its neighbors based on some column value. For example:
Compare sales from one month to the previous month (month-over-month or MoM change) or to the same month a year ago (year-over-year or YoY change). Compare financial results for a given period to the same period in the previous year (like-for-like or LFL analysis).</description></item><item><title>Base64 and other encodings in SQLite</title><link>https://antonz.org/sqlean-encode/</link><pubDate>Thu, 01 Jun 2023 18:30:00 +0000</pubDate><guid>https://antonz.org/sqlean-encode/</guid><description>You&amp;rsquo;ve probably heard about hexadecimal encoding in SQLite:
select hex(&amp;#39;hello&amp;#39;); -- 68656C6C6F select unhex(&amp;#39;68656C6C6F&amp;#39;); -- hello SQLite does not support other encoding algorithms by default. However, you can easily enable them using the sqlean-crypto extension (not related to cryptocurrency in any way).
Note. Unlike other DBMS, adding extensions to SQLite is a breeze. Download a file, run one database command — and you are good to go.
sqlean-crypto adds two functions:</description></item><item><title>LIMIT vs. FETCH in SQL</title><link>https://antonz.org/sql-fetch/</link><pubDate>Tue, 30 May 2023 18:00:00 +0000</pubDate><guid>https://antonz.org/sql-fetch/</guid><description>Fun fact: There is no limit clause in the SQL standard.
Everyone uses limit:
select * from employees order by salary desc limit 5; ┌────┬───────┬────────────┬────────┐ │ id │ name │ department │ salary │ ├────┼───────┼────────────┼────────┤ │ 25 │ Frank │ it │ 120 │ │ 23 │ Henry │ it │ 104 │ │ 24 │ Irene │ it │ 104 │ │ 33 │ Alice │ sales │ 100 │ │ 31 │ Cindy │ sales │ 96 │ └────┴───────┴────────────┴────────┘ And yet, according to the standard, we should be using fetch:</description></item><item><title>SQL Recipe: Segmenting Data</title><link>https://antonz.org/sql-segmenting/</link><pubDate>Tue, 23 May 2023 15:30:00 +0000</pubDate><guid>https://antonz.org/sql-segmenting/</guid><description>This post is part of the &amp;ldquo;SQL Recipes&amp;rdquo; series, where I provide short patterns for solving common SQL data analysis tasks.
Suppose we want to divide our data into several segments based on the value of one or more columns (e.g., to assign customers or products to different groups for marketing purposes).
The solution is to use the ntile() function over an SQL window ordered by target columns.
Example Let&amp;rsquo;s divide the employees into three groups according to their salary:</description></item><item><title>SQL Cheat Sheet</title><link>https://antonz.org/sql-cheatsheet/</link><pubDate>Sun, 14 May 2023 13:00:00 +0000</pubDate><guid>https://antonz.org/sql-cheatsheet/</guid><description>This is a short cheat sheet for those who were once familiar with SQL selects, but haven&amp;rsquo;t given it much practice since. The examples are interactive, so you can both read and practice.
We will use the toy employees table:
┌────┬───────┬────────┬────────────┬────────┐ │ id │ name │ city │ department │ salary │ ├────┼───────┼────────┼────────────┼────────┤ │ 11 │ Diane │ London │ hr │ 70 │ │ 12 │ Bob │ London │ hr │ 78 │ │ 21 │ Emma │ London │ it │ 84 │ │ 22 │ Grace │ Berlin │ it │ 90 │ │ 23 │ Henry │ London │ it │ 104 │ │ 24 │ Irene │ Berlin │ it │ 104 │ │ 25 │ Frank │ Berlin │ it │ 120 │ │ 31 │ Cindy │ Berlin │ sales │ 96 │ │ 32 │ Dave │ London │ sales │ 96 │ │ 33 │ Alice │ Berlin │ sales │ 100 │ └────┴───────┴────────┴────────────┴────────┘ Basics The basic building blocks of an SQL query.</description></item></channel></rss>