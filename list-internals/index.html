<!doctype html><html lang=en>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<title>How Python list really works</title>
<meta name=description content="And why some methods take constant time while others take linear.">
<meta name=robots content="index, follow">
<link rel=stylesheet type=text/css href=/assets/css/style.e6184ba015844ba539de86958bfe4288667bb47e8fed4c5bf3fb81e99f50b0be.css>
<link rel=icon href=/assets/favicon/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=/assets/favicon/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=/assets/favicon/favicon-32x32.png>
<link rel=apple-touch-icon href=/assets/favicon/apple-touch-icon.png>
<link rel=mask-icon href=/assets/favicon/safari-pinned-tab.svg>
<meta name=theme-color content="#fff">
<meta name=msapplication-TileColor content="#fff">
<link rel=canonical href=https://antonz.org/list-internals/>
<meta name=author content="Anton Zhiyanov">
<meta property="og:site_name" content="Anton Zhiyanov">
<meta property="og:type" content="article">
<meta property="og:title" content="How Python list really works">
<meta property="og:description" content="And why some methods take constant time while others take linear.">
<meta property="og:url" content="https://antonz.org/list-internals/">
<meta property="og:image" content="https://antonz.org/list-internals/cover.png">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:title content="How Python list really works">
<meta name=twitter:description content="And why some methods take constant time while others take linear.">
<meta name=twitter:url content="https://antonz.org/list-internals/">
<meta name=twitter:site content="@nalgeon">
<meta name=twitter:image content="https://antonz.org/list-internals/cover.png"></head>
<body>
<div class=header>
<div class=container>
<div class=row>
<div class="col-xs-6 col-sm-3">
<a class=img-link href=/>
<img src=/assets/stopwar.svg class=header-icon>
</a> 
<a href=/>
<strong>Anton Zhiyanov</strong>
</a>
</div>
<div class="col-xs-12 col-sm-6 col-md-4 hidden-mobile">
<a class=menu__link href=/all/>
<span>blog</span>
</a>
<a class=menu__link href=/#about>
<span>contacts</span>
</a>
<a class=menu__link href=https://antonz.ru>
<span>ru</span>
</a>
</div>
</div>
</div>
</div>
<div class=storey>
<div class=container>
<article class=post>
<div class=row>
<div class="col-xs-12 col-sm-10 article">
<header>
<h1>How Python list really works</h1>
</header>
<p><em>This post is largely about the arrays — the #1 data structure in the world. If you are not a data structure guru yet, I guarantee that you will better understand Python lists, their advantages and limitations. If you already know everything — there is no harm in refreshing the key points.</em></p>
<p>Everybody knows how to work with lists in Python:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#000>&gt;&gt;&gt;</span> <span style=color:#000>guests</span> <span style=color:#000>=</span> [<span style=color:#c41a16>&#34;Frank&#34;</span>, <span style=color:#c41a16>&#34;Claire&#34;</span>, <span style=color:#c41a16>&#34;Zoe&#34;</span>]
<span style=color:#000>&gt;&gt;&gt;</span> <span style=color:#000>guests</span>[<span style=color:#1c01ce>1</span>]
<span style=color:#c41a16>&#39;Claire&#39;</span>
</code></pre></div><p>Surely you know that selecting an item by index — <code>guests[idx]</code> — works instantly even on a million elements list. More precisely, selection by index takes constant time O(1) — that is, it does not depend on the number of items in the list.</p>
<p>Do you know why it works so fast? Let&rsquo;s find out.</p>
<h2 id=list--array>List = array?</h2>
<p>The list is based on an array. An array is a set of elements ① of the same size, ② located in memory one after another, without gaps.</p>
<p>Since elements are the same size and placed contiguously, it is easy to get an array item by index. All we need is the memory address of the very first element (the &ldquo;head&rdquo; of the array).</p>
<p>Let&rsquo;s say the head is located at the address <code>0×00001234</code>, and each item occupies 8 bytes. Then the element with the <code>idx</code> index is located at <code>0×00001234 + idx*8</code>:</p>
<div class=row>
<div class="col-xs-12 col-sm-6">
<figure>
<img alt="List = array" src=array-1.png class=img-bordered-thin>
</figure>
</div>
</div>
<p>Since the &ldquo;get value by address&rdquo; memory operation takes constant time, selecting an array item by index also takes O(1).</p>
<p>Roughly speaking, this is how Python list works. It stores a pointer to the head of the array and the number of items in the array. The item count is stored separately so that the <code>len()</code> function also performs in O(1) time, and does not have to count the elements each time.</p>
<p>So far so good. But there are a couple of problems:</p>
<ul>
<li>All array elements are the same size, but the list should be able to store items of different sizes (true/false, numbers, strings of different lengths).</li>
<li>The array has a fixed length, but the list should be able to store an arbitrary number of items.</li>
</ul>
<p>We&rsquo;ll tackle them a bit later.</p>
<h2 id=a-very-primitive-list>A very primitive list</h2>
<p>The best way to master a data structure is to implement it from scratch. Unfortunately, Python is not well suited for such low-level structures as arrays, because it doesn&rsquo;t support explicit pointers (addresses in memory).</p>
<p>This is probably as close as we can get:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#a90d91>class</span> <span style=color:#3f6e75>OhMyList</span>:
    <span style=color:#a90d91>def</span> <span style=color:#000>__init__</span>(<span style=color:#5b269a>self</span>):
        <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>
        <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>capacity</span> <span style=color:#000>=</span> <span style=color:#1c01ce>8</span>
        <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>array</span> <span style=color:#000>=</span> (<span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>capacity</span> <span style=color:#000>*</span> <span style=color:#000>ctypes</span><span style=color:#000>.</span><span style=color:#000>py_object</span>)()

    <span style=color:#a90d91>def</span> <span style=color:#000>append</span>(<span style=color:#5b269a>self</span>, <span style=color:#000>item</span>):
        <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>array</span>[<span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span>] <span style=color:#000>=</span> <span style=color:#000>item</span>
        <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span> <span style=color:#000>+=</span> <span style=color:#1c01ce>1</span>

    <span style=color:#a90d91>def</span> <span style=color:#000>__len__</span>(<span style=color:#5b269a>self</span>):
        <span style=color:#a90d91>return</span> <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span>

    <span style=color:#a90d91>def</span> <span style=color:#000>__getitem__</span>(<span style=color:#5b269a>self</span>, <span style=color:#000>idx</span>):
        <span style=color:#a90d91>return</span> <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>array</span>[<span style=color:#000>idx</span>]
</code></pre></div><p>Our custom list has a fixed capacity (<code>capacity</code> = 8 items) and stores the elements in the <code>array</code> array.</p>
<p>The <code>ctypes</code> module gives access to the low-level structures on which the standard library is built. In this case, we use it to create a C-style array of <code>capacity</code> elements.</p>
<h2 id=list--array-of-pointers>List = array of pointers</h2>
<p>The list instantly retrieves an item by index, because it has an array inside. And the array is so fast because all the elements are the same size.</p>
<p>But list items can be of different sizes:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#000>guests</span> <span style=color:#000>=</span> [<span style=color:#c41a16>&#34;Frank&#34;</span>, <span style=color:#c41a16>&#34;Claire&#34;</span>, <span style=color:#c41a16>&#34;Zoe&#34;</span>, <span style=color:#a90d91>True</span>, <span style=color:#1c01ce>42</span>]
</code></pre></div><p>To solve this problem, someone came up with the idea of storing item <em>pointers</em> instead of item <em>values</em>. Each element of the array is a memory address, and if you follow this address — you will get the actual value:</p>
<div class=row>
<div class="col-xs-12 col-sm-10">
<figure>
<img alt="List = array of pointers" src=array-2.png class=img-bordered-thin>
<figcaption>The array stores pointers adjacently. But the values they refer to can be stored anywhere in memory.</figcaption>
</figure>
</div>
</div>
<p>Since pointers are fixed size (8 bytes on modern 64-bit processors), everything works fine. Instead of one operation (get the value from the array cell), we&rsquo;ve now got two:</p>
<ol>
<li>Get the address from the array cell.</li>
<li>Get the value at that address.</li>
</ol>
<p>But it&rsquo;s still constant time O(1).</p>
<h2 id=list--dynamic-array>List = dynamic array</h2>
<p>If there are empty spaces left in the array underneath the list, then the <code>.append(item)</code> runs in constant time. All it takes is to write a new value to a free cell and increase the element counter by 1:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#a90d91>def</span> <span style=color:#000>append</span>(<span style=color:#5b269a>self</span>, <span style=color:#000>item</span>):
    <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>array</span>[<span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span>] <span style=color:#000>=</span> <span style=color:#000>item</span>
    <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span> <span style=color:#000>+=</span> <span style=color:#1c01ce>1</span>
</code></pre></div><p>But what if the array is already full?</p>
<p>Python has to allocate memory for a new, bigger array and copy all the old items to the new one:</p>
<div class=row>
<div class="col-xs-12 col-sm-6">
<figure>
<img alt="List = dynamic array" src=array-3.png class=img-bordered-thin>
<figcaption>When there is no more space in the old array, it's time to create a new one.</figcaption>
</figure>
</div>
</div>
<p>Here we go:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#a90d91>def</span> <span style=color:#000>append</span>(<span style=color:#5b269a>self</span>, <span style=color:#000>item</span>):
    <span style=color:#a90d91>if</span> <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span> <span style=color:#000>==</span> <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>capacity</span>:
        <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>_resize</span>(<span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>capacity</span><span style=color:#000>*</span><span style=color:#1c01ce>2</span>)
    <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>array</span>[<span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span>] <span style=color:#000>=</span> <span style=color:#000>item</span>
    <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span> <span style=color:#000>+=</span> <span style=color:#1c01ce>1</span>

<span style=color:#a90d91>def</span> <span style=color:#000>_resize</span>(<span style=color:#5b269a>self</span>, <span style=color:#000>new_cap</span>):
    <span style=color:#000>new_arr</span> <span style=color:#000>=</span> (<span style=color:#000>new_cap</span> <span style=color:#000>*</span> <span style=color:#000>ctypes</span><span style=color:#000>.</span><span style=color:#000>py_object</span>)()
    <span style=color:#a90d91>for</span> <span style=color:#000>idx</span> <span style=color:#000>in</span> <span style=color:#a90d91>range</span>(<span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>length</span>):
        <span style=color:#000>new_arr</span>[<span style=color:#000>idx</span>] <span style=color:#000>=</span> <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>array</span>[<span style=color:#000>idx</span>]
    <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>array</span> <span style=color:#000>=</span> <span style=color:#000>new_arr</span>
    <span style=color:#5b269a>self</span><span style=color:#000>.</span><span style=color:#000>capacity</span> <span style=color:#000>=</span> <span style=color:#000>new_cap</span>
</code></pre></div><p><code>._resize()</code> is a costly operation, so the new array should be significantly larger than the old one. In the example above, the new array is twice as large. Python uses a more modest coefficient — about 1.12.</p>
<p>If you remove more than half of the items from the list via <code>.pop()</code>, Python will shrink it. It&rsquo;ll allocate a new, smaller array and move the elements into it.</p>
<p>Thus, the list juggles arrays all the time so that we don&rsquo;t have to do it ツ</p>
<h2 id=appending-an-item-to-the-list>Appending an item to the list</h2>
<p>Selecting from the list by index takes O(1) time — we have sorted that out. The <code>.append(item)</code> method is also O(1) until Python has to extend the array under the list. But array extension is an O(n) operation. So how long does <code>.append()</code> take after all?</p>
<p>It would be wrong to measure a single append — as we found out, sometimes it takes O(1), sometimes O(n). So computer scientists came up with <em>amortized analysis</em>. To get an amortized operation time, one estimates the total time that a sequence of K operations will take, then divide it by K.</p>
<p>Without going into details, I will say that the amortized time for <code>.append(item)</code> turns out to be constant — O(1). So appending to the list works very fast.</p>
<div class=boxed>
<h3>Why amortized append time is O(1)</h3>
<p>Let's say the list is empty and want to append <code>n</code> items. For simplicity, we'll use the expansion factor of 2. Let's count the number of atomic operations:</p>
<ul>
<li>1st item: 1 (copy) + 1 (insert)</li>
<li>another 2: 2 (copy) + 2 (insert)</li>
<li>another 4: 4 (copy) + 4 (insert)</li>
<li>another 8: 8 (copy) + 8 (insert)</li>
<li>...</li>
</ul>
<p>For <code>n</code> items there will be <code>n</code> insertions.</p>
<p>As for copy:</p>
<pre><code>1 + 2 + 4 + ... log(n) = 
= 2**log(n) * 2 - 1 =
= 2n - 1</code></pre>
<p>operations.</p>
<p>So for <code>n</code> items there will be <code>3n - 1</code> atomic operations.</p>
<p><code>O((3n - 1) / n)</code> = <code>O(1)</code></p>
</div>
<p>Summing up, the following operations are guaranteed to be fast:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#177500># O(1)</span>
<span style=color:#000>lst</span>[<span style=color:#000>idx</span>]

<span style=color:#177500># O(1)</span>
<span style=color:#a90d91>len</span>(<span style=color:#000>lst</span>)

<span style=color:#177500># amortized O(1)</span>
<span style=color:#000>lst</span><span style=color:#000>.</span><span style=color:#000>append</span>(<span style=color:#000>item</span>)
<span style=color:#000>lst</span><span style=color:#000>.</span><span style=color:#000>pop</span>()
</code></pre></div><h2 id=summary>Summary</h2>
<p>As we found out, these operations are O(1):</p>
<ul>
<li>select an item by index <code>lst[idx]</code></li>
<li>count items <code>len(lst)</code></li>
<li>add an item to the end of the list <code>.append(item)</code></li>
<li>remove an item from the end of the list <code>.pop()</code></li>
</ul>
<p>Other operations are &ldquo;slow&rdquo;:</p>
<ul>
<li>Insert or delete an item by index. <code>.insert(idx, item)</code> and <code>.pop(idx)</code> take linear time O(n) because they shift all the elements after the target one.</li>
<li>Search or delete an item by value. <code>item in lst</code>, <code>.index(item)</code> and <code>.remove(item)</code> take linear time O(n) because they iterate over all the elements.</li>
<li>Select a slice of <code>k</code> elements. <code>lst[from:to]</code> takes O(k).</li>
</ul>
<p>Does this mean that you should not use &ldquo;slow&rdquo; operations? Of course not. If you have a list of 1000 items, the difference between O(1) and O(n) for a single operation is insignificant.</p>
<p>On the other hand, if you perform a &ldquo;slow&rdquo; operation on a list of 1000 items a million times — this is quite significant. The same goes if you invoke a single &ldquo;slow&rdquo; operation on a list of a million items.</p>
<p>Therefore, it is useful to know which list methods take constant time and which take linear time — to make a conscious decision in a specific situation.</p>
<p>I hope you&rsquo;ll see Python lists in a new way after this article. Thanks for reading!</p>
<p><em>Follow <a href=https://twitter.com/ohmypy>@ohmypy</a> on Twitter to keep up with new posts 🚀</em></p>
<p><a href="https://news.ycombinator.com/item?id=29217038">Comments on Hacker News</a></p>
</div>
</div><footer class=post__footer>
<div class=row>
<div class=col-xs-12>
<div class=post__date>
<time datetime="2021-11-12 17:55:00 +0000 UTC">12 Nov, 2021</time>
</div>
<div class=post__tags>
<a href=https://antonz.org/tags/python/>python</a>&nbsp;
</div>
</div>
</div>
</footer></article>
<aside class=post__related>
<div class="post__nav article">
<div class=row>
<div class="col-xs-12 col-sm-6">
<p>&larr;&nbsp;<a href=https://antonz.org/sqlite-playground/>SQLite playground in the browser</a></p>
</div>
<div class="col-xs-12 col-sm-6">
<p><a href=https://antonz.org/sqlite-3-37/>What's new in SQLite 3.37</a>&nbsp;&rarr;</p>
</div>
</div>
</div>
<div class=article>
<div class=row>
<div class="col-xs-12 col-sm-8 col-md-6">
<h3>See also</h3>
<p><a href=/good-code/>Good Code Criterion</a></p>
<p><a href=/python-packaging/>How to make an awesome Python package in 2021</a></p>
<p><a href=/makefile-automation/>Automate your Python project with Makefile</a></p>
</div>
</div>
</div>
</aside>
</div>
</div>
<footer class="container footer">
<ul class=naked-list>
<li class=footer__item>Subscribe:
<a href=https://twitter.com/ohmypy class=footer__social-link><i class="fab fa-twitter"></i><span>Twitter</span></a>
<a href=/index.xml class=footer__social-link><i class="fas fa-rss"></i><span>RSS</span></a>
</li>
<li class=footer__item>Email: <a href=mailto:m@antonz.org>m@antonz.org</a></li>
</ul>
</footer>
<script async src=//gc.zgo.at/count.js data-goatcounter=https://antonzorg.goatcounter.com/count></script></body>
</html>