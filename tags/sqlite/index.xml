<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sqlite on Anton Zhiyanov</title><link>https://antonz.org/tags/sqlite/</link><description>Recent content in sqlite on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jun 2023 18:30:00 +0000</lastBuildDate><atom:link href="https://antonz.org/tags/sqlite/index.xml" rel="self" type="application/rss+xml"/><item><title>Base64 and other encodings in SQLite</title><link>https://antonz.org/sqlean-encode/</link><pubDate>Thu, 01 Jun 2023 18:30:00 +0000</pubDate><guid>https://antonz.org/sqlean-encode/</guid><description>You&amp;rsquo;ve probably heard about hexadecimal encoding in SQLite:
select hex(&amp;#39;hello&amp;#39;); -- 68656C6C6F select unhex(&amp;#39;68656C6C6F&amp;#39;); -- hello SQLite does not support other encoding algorithms by default. However, you can easily enable them using the sqlean-crypto extension (not related to cryptocurrency in any way).
Note. Unlike other DBMS, adding extensions to SQLite is a breeze. Download a file, run one database command — and you are good to go.
sqlean-crypto adds two functions:</description></item><item><title>AI SQLite Assistant</title><link>https://antonz.org/sqlime-ai/</link><pubDate>Thu, 16 Mar 2023 12:00:00 +0000</pubDate><guid>https://antonz.org/sqlime-ai/</guid><description>While trying to trick AI into saying ethically questionable things may be fun for some of us, I prefer more practical and useful scenarios.
So, as of today, Sqlime — an online SQLite playground — includes the &amp;ldquo;Ask AI&amp;rdquo; feature.
AI can explain, teach, and troubleshoot your SQL without leaving the playground:
Write a question as a comment above the query. Click &amp;ldquo;Ask AI&amp;rdquo;. Receive a not-so-fast, but often useful answer from AI.</description></item><item><title>Interactive SQL Examples in JavaScript</title><link>https://antonz.org/interactive-sql-examples/</link><pubDate>Sun, 05 Mar 2023 12:00:00 +0000</pubDate><guid>https://antonz.org/interactive-sql-examples/</guid><description>Reading about SQL is fun, but trying out live examples is even better! So I created JavaScript widgets that turn static SQL code in your articles into interactive examples.
Here is a working example. Give it a try:
select * from employees limit 5; And here are the four steps to creating executable SQL examples in your own articles or documentation:
1. Include the widgets You&amp;rsquo;ll need three JavaScript files:</description></item><item><title>Reading and Writing Files in SQLite</title><link>https://antonz.org/sqlean-fileio/</link><pubDate>Sun, 26 Feb 2023 15:00:00 +0000</pubDate><guid>https://antonz.org/sqlean-fileio/</guid><description>Sometimes it&amp;rsquo;s useful to load a dataset from an external file or export query results to a file.
SQLite does not support file I/O operations by default. However, you can easily enable them using the sqlean-fileio extension.
Note. Unlike other DBMS, adding extensions to SQLite is a breeze. Download a file, run one database command — and you are good to go.
sqlean-fileio solves common import/export tasks such as:</description></item><item><title>Building a Pivot Table in SQLite</title><link>https://antonz.org/sqlite-pivot-table/</link><pubDate>Thu, 09 Feb 2023 14:00:00 +0000</pubDate><guid>https://antonz.org/sqlite-pivot-table/</guid><description>Suppose we have a sales table with product incomes for the years 2020-2023:
┌─────────┬──────┬────────┐ │ product │ year │ income │ ├─────────┼──────┼────────┤ │ alpha │ 2020 │ 100 │ │ alpha │ 2021 │ 120 │ │ alpha │ 2022 │ 130 │ │ alpha │ 2023 │ 140 │ │ beta │ 2020 │ 10 │ │ beta │ 2021 │ 20 │ │ beta │ 2022 │ 40 │ │ beta │ 2023 │ 80 │ │ gamma │ 2020 │ 80 │ │ gamma │ 2021 │ 75 │ │ gamma │ 2022 │ 78 │ │ gamma │ 2023 │ 80 │ └─────────┴──────┴────────┘ playground • download</description></item><item><title>Regular Expressions in SQLite</title><link>https://antonz.org/sqlean-regexp/</link><pubDate>Sat, 04 Feb 2023 11:20:00 +0000</pubDate><guid>https://antonz.org/sqlean-regexp/</guid><description>Regular expressions are probably the most powerful text processing tool without programming.
SQLite does not support regular expressions by default. However, you can easily enable them using the sqlean-regexp extension.
Note. Unlike other DBMS, adding extensions to SQLite is a breeze. Download a file, run one database command — and you are good to go.
With sqlean-regexp, matching a string against a pattern becomes as easy as:
-- count messages containing digits select count(*) from messages where msg_text regexp &amp;#39;\d+&amp;#39;; -- 42 Pattern matching and text replacement There are three main tasks people usually solve using regular expressions:</description></item><item><title>User-Defined Functions in SQLite</title><link>https://antonz.org/sqlean-define/</link><pubDate>Thu, 08 Sep 2022 15:30:00 +0000</pubDate><guid>https://antonz.org/sqlean-define/</guid><description>Most database engines provide a lot of built-in functions. Still, sometimes they are not enough, and people turn to writing their own — user-defined — functions in plain SQL or some SQL-based language (like pl/sql in Oracle or pl/pgsql in Postgres).
SQLite does not support user-defined functions by default. However, you can easily enable them using the sqlean-define extension.
Note. Unlike other DBMS, adding extensions to SQLite is a breeze.</description></item><item><title>Common Table Expressions in SQL</title><link>https://antonz.org/cte/</link><pubDate>Fri, 20 May 2022 16:50:00 +0000</pubDate><guid>https://antonz.org/cte/</guid><description>Rule #1 for writing well-readable SQL queries is to use common table expressions (CTE). People are afraid of them, but they really shouldn&amp;rsquo;t. Let&amp;rsquo;s learn CTEs in three minutes, so you don&amp;rsquo;t have to read a weighty SQL book or take an online course.
Problem Let&amp;rsquo;s say we have a table with monthly sales for two years:
┌──────┬───────┬───────┬──────────┬─────────┐ │ year │ month │ price │ quantity │ revenue │ ├──────┼───────┼───────┼──────────┼─────────┤ │ 2019 │ 1 │ 60 │ 200 │ 12000 │ │ 2019 │ 2 │ 60 │ 660 │ 39600 │ │ 2019 │ 3 │ 60 │ 400 │ 24000 │ │ 2019 │ 4 │ 60 │ 300 │ 18000 │ │ 2019 │ 5 │ 60 │ 440 │ 26400 │ │ 2019 │ 6 │ 60 │ 540 │ 32400 │ │ 2019 │ 7 │ 60 │ 440 │ 26400 │ │ 2019 │ 8 │ 60 │ 440 │ 26400 │ │ 2019 │ 9 │ 60 │ 250 │ 15000 │ │ 2019 │ 10 │ 60 │ 420 │ 25200 │ │ .</description></item><item><title>Temporary tables in SQLite</title><link>https://antonz.org/temp-tables/</link><pubDate>Wed, 18 May 2022 20:30:00 +0000</pubDate><guid>https://antonz.org/temp-tables/</guid><description>Sometimes you want to combine data from multiple tables into one and query the results. For example, join vacancies together with employers and regions:
select v.*, e.name, a.name from vacancy as v join employer as e on e.id = v.employer_id join area as a on a.id = v.area_id The question is how to reference the combined dataset in further queries. There are three ways of doing that:
Common Table Expressions (CTEs) Views Temporary tables A Common Table Expression is basically a named subquery:</description></item><item><title>JSON and virtual columns in SQLite</title><link>https://antonz.org/json-virtual-columns/</link><pubDate>Sun, 15 May 2022 11:25:00 +0000</pubDate><guid>https://antonz.org/json-virtual-columns/</guid><description>Generated columns have another great use case.
Let&amp;rsquo;s say you decide to keep a log of events that occur in the system. There are different types of events, each with its own set of fields. For example, sign-in:
{ &amp;#34;timestamp&amp;#34;: &amp;#34;2022-05-15T09:31:00Z&amp;#34;, &amp;#34;object&amp;#34;: &amp;#34;user&amp;#34;, &amp;#34;object_id&amp;#34;: 11, &amp;#34;action&amp;#34;: &amp;#34;login&amp;#34;, &amp;#34;details&amp;#34;: { &amp;#34;ip&amp;#34;: &amp;#34;192.168.0.1&amp;#34; } } Or account deposit:
{ &amp;#34;timestamp&amp;#34;: &amp;#34;2022-05-15T09:32:00Z&amp;#34;, &amp;#34;object&amp;#34;: &amp;#34;account&amp;#34;, &amp;#34;object_id&amp;#34;: 12, &amp;#34;action&amp;#34;: &amp;#34;deposit&amp;#34;, &amp;#34;details&amp;#34;: { &amp;#34;amount&amp;#34;: &amp;#34;1000&amp;#34;, &amp;#34;currency&amp;#34;: &amp;#34;USD&amp;#34; } } You decide to store the raw JSON, as normalization is non-trivial.</description></item></channel></rss>