<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sqlite on Anton Zhiyanov</title><link>https://antonz.org/tags/sqlite/</link><description>Recent content in sqlite on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 Sep 2022 15:30:00 +0000</lastBuildDate><atom:link href="https://antonz.org/tags/sqlite/index.xml" rel="self" type="application/rss+xml"/><item><title>User-defined functions in SQLite</title><link>https://antonz.org/sqlean-define/</link><pubDate>Thu, 08 Sep 2022 15:30:00 +0000</pubDate><guid>https://antonz.org/sqlean-define/</guid><description>Write functions in plain SQL using the &amp;lsquo;define&amp;rsquo; extension.
SQLite does not directly support user-defined functions. Sure, one can write a function in C or Python and register it within SQLite. But not in SQL itself.
Luckily for us, SQLite provides an extension mechanism. One of such extensions — define — allows writing functions in regular SQL.
With define writing a custom function becomes as easy as:
select define(&amp;#39;sumn&amp;#39;, &amp;#39;:n * (:n + 1) / 2&amp;#39;); And then using it as any built-in function:</description></item><item><title>Common Table Expressions in SQL</title><link>https://antonz.org/cte/</link><pubDate>Fri, 20 May 2022 16:50:00 +0000</pubDate><guid>https://antonz.org/cte/</guid><description>Rule #1 for writing well-readable SQL queries is to use common table expressions (CTE). People are afraid of them, but they really shouldn&amp;rsquo;t. Let&amp;rsquo;s learn CTEs in three minutes, so you don&amp;rsquo;t have to read a weighty SQL book or take an online course.
Problem Let&amp;rsquo;s say we have a table with monthly sales for two years:
┌──────┬───────┬───────┬──────────┬─────────┐ │ year │ month │ price │ quantity │ revenue │ ├──────┼───────┼───────┼──────────┼─────────┤ │ 2019 │ 1 │ 60 │ 200 │ 12000 │ │ 2019 │ 2 │ 60 │ 660 │ 39600 │ │ 2019 │ 3 │ 60 │ 400 │ 24000 │ │ 2019 │ 4 │ 60 │ 300 │ 18000 │ │ 2019 │ 5 │ 60 │ 440 │ 26400 │ │ 2019 │ 6 │ 60 │ 540 │ 32400 │ │ 2019 │ 7 │ 60 │ 440 │ 26400 │ │ 2019 │ 8 │ 60 │ 440 │ 26400 │ │ 2019 │ 9 │ 60 │ 250 │ 15000 │ │ 2019 │ 10 │ 60 │ 420 │ 25200 │ │ .</description></item><item><title>Temporary tables in SQLite</title><link>https://antonz.org/temp-tables/</link><pubDate>Wed, 18 May 2022 20:30:00 +0000</pubDate><guid>https://antonz.org/temp-tables/</guid><description>Sometimes you want to combine data from multiple tables into one and query the results. For example, join vacancies together with employers and regions:
select v.*, e.name, a.name from vacancy as v join employer as e on e.id = v.employer_id join area as a on a.id = v.area_id The question is how to reference the combined dataset in further queries. There are three ways of doing that:
Common Table Expressions (CTEs) Views Temporary tables A Common Table Expression is basically a named subquery:</description></item><item><title>JSON and virtual columns in SQLite</title><link>https://antonz.org/json-virtual-columns/</link><pubDate>Sun, 15 May 2022 11:25:00 +0000</pubDate><guid>https://antonz.org/json-virtual-columns/</guid><description>Generated columns have another great use case.
Let&amp;rsquo;s say you decide to keep a log of events that occur in the system. There are different types of events, each with its own set of fields. For example, sign-in:
{ &amp;#34;timestamp&amp;#34;: &amp;#34;2022-05-15T09:31:00Z&amp;#34;, &amp;#34;object&amp;#34;: &amp;#34;user&amp;#34;, &amp;#34;object_id&amp;#34;: 11, &amp;#34;action&amp;#34;: &amp;#34;login&amp;#34;, &amp;#34;details&amp;#34;: { &amp;#34;ip&amp;#34;: &amp;#34;192.168.0.1&amp;#34; } } Or account deposit:
{ &amp;#34;timestamp&amp;#34;: &amp;#34;2022-05-15T09:32:00Z&amp;#34;, &amp;#34;object&amp;#34;: &amp;#34;account&amp;#34;, &amp;#34;object_id&amp;#34;: 12, &amp;#34;action&amp;#34;: &amp;#34;deposit&amp;#34;, &amp;#34;details&amp;#34;: { &amp;#34;amount&amp;#34;: &amp;#34;1000&amp;#34;, &amp;#34;currency&amp;#34;: &amp;#34;USD&amp;#34; } } You decide to store the raw JSON, as normalization is non-trivial.</description></item><item><title>Generated columns in SQLite</title><link>https://antonz.org/generated-columns/</link><pubDate>Sat, 07 May 2022 17:10:00 +0000</pubDate><guid>https://antonz.org/generated-columns/</guid><description>Sometimes an SQL query field is calculated based on other table columns. Imagine a table with income and tax_rate columns:
┌────────┬──────────┐ │ income │ tax_rate │ ├────────┼──────────┤ │ 70 │ 0.22 │ │ 84 │ 0.22 │ │ 90 │ 0.24 │ └────────┴──────────┘ You can calculate the annual tax:
select id, income * tax_rate as tax from people; In order not to repeat these calculations everywhere, it is convenient to create a virtual generated column:</description></item><item><title>Multi-line queries in SQLite shell</title><link>https://antonz.org/sqlite-multiline/</link><pubDate>Sun, 24 Apr 2022 21:30:00 +0000</pubDate><guid>https://antonz.org/sqlite-multiline/</guid><description>Just after writing that debugging multi-line queries in SQLite shell is not easy, I discovered a cool trick on the sqlite forum:
Use Ctrl+V, Ctrl+J instead of Enter for new lines. After that, edit the query with the ↑ button.
And here are some more ways to edit multi-line queries:
Use external editor (.shell &amp;lt;editor&amp;gt; &amp;lt;file&amp;gt;) Run query from file (.read &amp;lt;file&amp;gt;) Consider DBeaver, DataGrip or other UI tool</description></item><item><title>SQLite CLI command history</title><link>https://antonz.org/sqlite-history/</link><pubDate>Sun, 17 Apr 2022 14:50:00 +0000</pubDate><guid>https://antonz.org/sqlite-history/</guid><description>SQLite command line tool (sqlite3 or sqlite3.exe) remembers the last 2000 executed commands. To repeat the last command, just press the ↑ key, to search for older ones — use Ctrl+R shortcut.
It's faster to find a query than to type it again By default, SQLite stores the history file in the user&amp;rsquo;s home directory and names it .sqlite_history. It&amp;rsquo;s in plain text, so you can view it in your favorite editor.</description></item><item><title>The ultimate SQLite extension set</title><link>https://antonz.org/sqlean/</link><pubDate>Tue, 04 Jan 2022 13:00:00 +0000</pubDate><guid>https://antonz.org/sqlean/</guid><description>I really like SQLite. It&amp;rsquo;s a miniature embedded database, perfect for both exploratory data analysis and as a storage for small apps (I&amp;rsquo;ve blogged about that previously).
It has a minor drawback though. There are few built-in functions compared to PostgreSQL or Oracle. Fortunately, the authors provided an extension mechanism, which allows doing almost anything. As a result, there are a lot of SQLite extensions out there, but they are incomplete, inconsistent and scattered across the internet.</description></item><item><title>What's new in SQLite 3.37</title><link>https://antonz.org/sqlite-3-37/</link><pubDate>Sun, 28 Nov 2021 15:25:00 +0000</pubDate><guid>https://antonz.org/sqlite-3-37/</guid><description>Unlike 3.35, release 3.37 didn&amp;rsquo;t bring many changes. But among them is one of the most important in the history of SQLite: the &amp;ldquo;strict&amp;rdquo; table mode, in which the engine makes sure that the data in the column matches the type.
Perhaps now SQLite will no longer be called &amp;ldquo;the JavaScript of the DBMS world&amp;rdquo; ツ But let&amp;rsquo;s take it one piece at a time.
The problem with types SQLite supports 5 data types:</description></item><item><title>SQLite playground in the browser</title><link>https://antonz.org/sqlite-playground/</link><pubDate>Mon, 04 Oct 2021 10:40:00 +0000</pubDate><guid>https://antonz.org/sqlite-playground/</guid><description>What I&amp;rsquo;ve always lacked is something similar to JSFiddle, but for SQLite. An online playground to quickly test an SQL query and share it with others.
Here is what I wanted:
Binary database import, not just SQL schema. Support both local and remote databases (by url). Save the database and queries in the cloud. Free of charge, no sign-up required. The latest version of SQLite. Minimalistic and mobile friendly. So I&amp;rsquo;ve built SQLime — an online SQLite playground for debugging and sharing SQL snippets.</description></item></channel></rss>