<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on Anton Zhiyanov</title><link>https://antonz.org/tags/python/</link><description>Recent content in python on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 31 May 2022 17:00:00 +0000</lastBuildDate><atom:link href="https://antonz.org/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Flying Pig, or Protocols in Python</title><link>https://antonz.org/protocol/</link><pubDate>Tue, 31 May 2022 17:00:00 +0000</pubDate><guid>https://antonz.org/protocol/</guid><description>Let&amp;rsquo;s say you&amp;rsquo;ve developed a utility that sends everything flying:
def launch(thing): thing.fly() Well, not exactly everything. Things with the fly() method, to be precise. With a single handy function we launch Frank (he&amp;rsquo;s a pigeon), an airplane, and even Superman:
class Frank: def fly(self): print(&amp;#34;üí©&amp;#34;) class Plane: def fly(self): print(&amp;#34;Flight delayed&amp;#34;) class Superman: def fly(self): print(&amp;#34;Œµ===(„Å£‚âßœâ‚â¶)„Å£&amp;#34;) Whoosh:
f = Frank() launch(f) # üí© p = Plane() launch(p) # Flight delayed s = Superman() launch(s) # Œµ===(„Å£‚âßœâ‚â¶)„Å£ It&amp;rsquo;s not that our heroes are particularly successful at coping with the task, but the launch works for them.</description></item><item><title>Random numbers and sequences in Python</title><link>https://antonz.org/random/</link><pubDate>Mon, 23 May 2022 15:30:00 +0000</pubDate><guid>https://antonz.org/random/</guid><description>Everybody knows about random.randint(a, b) in Python, which returns a¬†‚â§¬†n¬†‚â§¬†b:
random.randint(10, 99) # 59 But the random module has so much more to offer.
Like selecting a number from a range with a step:
random.randrange(10, 99, 3) # 91 Or a random sequence element:
numbers = [7, 9, 13, 42, 64, 99] random.choice(numbers) # 42 Or multiple elements:
numbers = range(99, 10, -1) random.choices(numbers, k=3) # [32, 62, 76] How about choosing some elements more often than others?</description></item><item><title>Compact objects in Python</title><link>https://antonz.org/compact-objects/</link><pubDate>Fri, 13 May 2022 20:25:00 +0000</pubDate><guid>https://antonz.org/compact-objects/</guid><description>Python is an object language. This is nice and cozy until you are out of memory holding 10 million objects at once. Let&amp;rsquo;s talk about how to reduce appetite.
Visit the Playground to try out the code samples
Tuples Imagine you have a simple Pet object with the name (string) and price (integer) attributes. Intuitively, it seems that the most compact representation is a tuple:
(&amp;#34;Frank the Pigeon&amp;#34;, 50000) Let&amp;rsquo;s measure how much memory this beauty eats:</description></item><item><title>Python Standard Library changes in recent years</title><link>https://antonz.org/python-stdlib-changes/</link><pubDate>Wed, 11 May 2022 12:40:00 +0000</pubDate><guid>https://antonz.org/python-stdlib-changes/</guid><description>With each major Python release, all the attention goes to the new language features: the walrus operator, dictionary merging, pattern matching. There is also a lot of writing about asyncio and typing modules ‚Äî they are developing rapidly and are obviously important for the core team.
The rest of the standard library modules receive undeservedly little attention. I want to fix this and tell you about the novelties introduced in versions 3.</description></item><item><title>Page iterator in Python</title><link>https://antonz.org/page-iterator/</link><pubDate>Mon, 02 May 2022 13:00:00 +0000</pubDate><guid>https://antonz.org/page-iterator/</guid><description>Suppose you are counting stats for a huge dataset of toys sold across the country over the past year:
reader = fetch_toys() for item in reader: process_single(item) process_single() takes 10¬†ms, so 400¬†million toys will be processed in 46¬†days üò±
After a number of intense conversations, you manage to convince the developers that it&amp;rsquo;s not very fast. process_batch() function enters the scene. It processes 10,000 toys in 1¬†second.</description></item><item><title>Caching slow functions in Python</title><link>https://antonz.org/functools-cache/</link><pubDate>Sat, 23 Apr 2022 19:10:00 +0000</pubDate><guid>https://antonz.org/functools-cache/</guid><description>Suppose you wrote a function that returns the user&amp;rsquo;s email:
def get_user_email(user_id): user = find_by_id(user_id) return user[&amp;#34;email&amp;#34;] But there is a problem. find_by_id() calls a terribly slow legacy system:
def find_by_id(user_id): # simulate a slow network request, # returning a user by their id time.sleep(1) return { &amp;#34;email&amp;#34;: &amp;#34;...&amp;#34; } 100 calls for get_user_email(42) result in 100 slow requests. A single one should be quite enough, so let&amp;rsquo;s attach a simple cache:</description></item><item><title>How Python list really works</title><link>https://antonz.org/list-internals/</link><pubDate>Fri, 12 Nov 2021 17:55:00 +0000</pubDate><guid>https://antonz.org/list-internals/</guid><description>This post is largely about the arrays ‚Äî the #1 data structure in the world. If you are not a data structure guru yet, I guarantee that you will better understand Python lists, their advantages and limitations. If you already know everything ‚Äî there is no harm in refreshing the key points.
Everybody knows how to work with lists in Python:
&amp;gt;&amp;gt;&amp;gt; guests = [&amp;#34;Frank&amp;#34;, &amp;#34;Claire&amp;#34;, &amp;#34;Zoe&amp;#34;] &amp;gt;&amp;gt;&amp;gt; guests[1] &amp;#39;Claire&amp;#39; Surely you know that selecting an item by index ‚Äî guests[idx] ‚Äî works instantly even on a million elements list.</description></item><item><title>How to make an awesome Python package</title><link>https://antonz.org/python-packaging/</link><pubDate>Tue, 06 Apr 2021 20:30:00 +0300</pubDate><guid>https://antonz.org/python-packaging/</guid><description>If you are like me, every once in a while you write a useful python utility and want to share it with your colleagues. The best way to do this is to make a package: it easy to install and saves from copy-pasting.
If you are like me, you might be thinking that creating packages is a real headache. Well, that&amp;rsquo;s not the case anymore. And I am going to prove it with this step-by-step guide.</description></item><item><title>Automate your Python project with Makefile</title><link>https://antonz.org/makefile-automation/</link><pubDate>Tue, 16 Mar 2021 17:15:00 +0000</pubDate><guid>https://antonz.org/makefile-automation/</guid><description>When working on a library or application, certain tasks tend to show up over and over again:
checking the code with linters, running tests with coverage, deploying with Docker, &amp;hellip; JS developers are lucky (ha!): their package.json has a special scripts section for this stuff:
{ ... &amp;quot;scripts&amp;quot;: { &amp;quot;format&amp;quot;: &amp;quot;prettier --write \&amp;quot;src/**/*.ts\&amp;quot;&amp;quot;, &amp;quot;lint&amp;quot;: &amp;quot;tslint -p tsconfig.json&amp;quot;, &amp;quot;test&amp;quot;: &amp;quot;jest --coverage --config jestconfig.json&amp;quot;, }, ... } Nothing like this is provided with Python.</description></item></channel></rss>