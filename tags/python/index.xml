<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on Anton Zhiyanov</title><link>https://antonz.org/tags/python/</link><description>Recent content in python on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 13 May 2022 20:25:00 +0000</lastBuildDate><atom:link href="https://antonz.org/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Compact objects in Python</title><link>https://antonz.org/compact-objects/</link><pubDate>Fri, 13 May 2022 20:25:00 +0000</pubDate><guid>https://antonz.org/compact-objects/</guid><description>Python is an object language. This is nice and cozy until you are out of memory holding 10 million objects at once. Let&amp;rsquo;s talk about how to reduce appetite.
Imagine you have a simple Pet object with the name (string) and price (integer) attributes. Intuitively, it seems that the most compact representation is a tuple:
(&amp;#34;Francis II&amp;#34;, 50000) Let&amp;rsquo;s measure how much memory this beauty eats:
import random from pympler.asizeof import asizeof def fields(): name_gen = (random.</description></item><item><title>Python Standard Library changes in recent years</title><link>https://antonz.org/python-stdlib-changes/</link><pubDate>Wed, 11 May 2022 12:40:00 +0000</pubDate><guid>https://antonz.org/python-stdlib-changes/</guid><description>With each major Python release, all the attention goes to the new language features: the walrus operator, dictionary merging, pattern matching. There is also a lot of writing about asyncio and typing modules â€” they are developing rapidly and are obviously important for the core team.
The rest of the standard library modules receive undeservedly little attention. I want to fix this and tell you about the novelties introduced in versions 3.</description></item><item><title>Page iterator in Python</title><link>https://antonz.org/page-iterator/</link><pubDate>Mon, 02 May 2022 13:00:00 +0000</pubDate><guid>https://antonz.org/page-iterator/</guid><description>Suppose you are counting stats for a huge dataset of toys sold across the country over the past year:
reader = fetch_toys() for item in reader: process_single(item) process_single() takes 10Â ms, so 400Â million toys will be processed in 46Â days ðŸ˜±
After a number of intense conversations, you manage to convince the developers that it&amp;rsquo;s not very fast. process_batch() function enters the scene. It processes 10,000 toys in 1Â second.</description></item><item><title>Caching slow functions in Python</title><link>https://antonz.org/functools-cache/</link><pubDate>Sat, 23 Apr 2022 19:10:00 +0000</pubDate><guid>https://antonz.org/functools-cache/</guid><description>Suppose you wrote a function that returns the user&amp;rsquo;s email:
def get_user_email(user_id): user = find_by_id(user_id) return user[&amp;#34;email&amp;#34;] But there is a problem. find_by_id() calls a terribly slow legacy system:
def find_by_id(user_id): # simulate a slow network request, # returning a user by their id time.sleep(1) return { &amp;#34;email&amp;#34;: &amp;#34;...&amp;#34; } 100 calls for get_user_email(42) result in 100 slow requests. A single one should be quite enough, so let&amp;rsquo;s attach a simple cache:</description></item><item><title>How Python list really works</title><link>https://antonz.org/list-internals/</link><pubDate>Fri, 12 Nov 2021 17:55:00 +0000</pubDate><guid>https://antonz.org/list-internals/</guid><description>This post is largely about the arrays â€” the #1 data structure in the world. If you are not a data structure guru yet, I guarantee that you will better understand Python lists, their advantages and limitations. If you already know everything â€” there is no harm in refreshing the key points.
Everybody knows how to work with lists in Python:
&amp;gt;&amp;gt;&amp;gt; guests = [&amp;#34;Frank&amp;#34;, &amp;#34;Claire&amp;#34;, &amp;#34;Zoe&amp;#34;] &amp;gt;&amp;gt;&amp;gt; guests[1] &amp;#39;Claire&amp;#39; Surely you know that selecting an item by index â€” guests[idx] â€” works instantly even on a million elements list.</description></item><item><title>How to make an awesome Python package</title><link>https://antonz.org/python-packaging/</link><pubDate>Tue, 06 Apr 2021 20:30:00 +0300</pubDate><guid>https://antonz.org/python-packaging/</guid><description>If you are like me, every once in a while you write a useful python utility and want to share it with your colleagues. The best way to do this is to make a package: it easy to install and saves from copy-pasting.
If you are like me, you might be thinking that creating packages is a real headache. Well, that&amp;rsquo;s not the case anymore. And I am going to prove it with this step-by-step guide.</description></item><item><title>Automate your Python project with Makefile</title><link>https://antonz.org/makefile-automation/</link><pubDate>Tue, 16 Mar 2021 17:15:00 +0000</pubDate><guid>https://antonz.org/makefile-automation/</guid><description>When working on a library or application, certain tasks tend to show up over and over again:
checking the code with linters, running tests with coverage, deploying with Docker, &amp;hellip; JS developers are lucky (ha!): their package.json has a special scripts section for this stuff:
{ ... &amp;quot;scripts&amp;quot;: { &amp;quot;format&amp;quot;: &amp;quot;prettier --write \&amp;quot;src/**/*.ts\&amp;quot;&amp;quot;, &amp;quot;lint&amp;quot;: &amp;quot;tslint -p tsconfig.json&amp;quot;, &amp;quot;test&amp;quot;: &amp;quot;jest --coverage --config jestconfig.json&amp;quot;, }, ... } Nothing like this is provided with Python.</description></item></channel></rss>