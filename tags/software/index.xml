<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software on Anton Zhiyanov</title><link>https://antonz.org/tags/software/</link><description>Recent content in Software on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 21 Dec 2022 16:50:00 +0000</lastBuildDate><atom:link href="https://antonz.org/tags/software/index.xml" rel="self" type="application/rss+xml"/><item><title>Speed of algorithms (with cats)</title><link>https://antonz.org/big-o/</link><pubDate>Wed, 21 Dec 2022 16:50:00 +0000</pubDate><guid>https://antonz.org/big-o/</guid><description>Let&amp;rsquo;s see how programmers evaluate fast and slow algorithms. Since the topic is pretty boring, we&amp;rsquo;ll use silly cat examples.
Constant time: O(1) This is your best option. The algorithm speed does not depend on the number of cats.
üêæ Example
You are the lucky owner of N cats. Every kitten knows their name. If you call "Felix!", only one will come running, and the rest of the N-1 fluffs don't care.</description></item><item><title>Storing state in the URL</title><link>https://antonz.org/storing-state/</link><pubDate>Sun, 08 May 2022 11:30:00 +0000</pubDate><guid>https://antonz.org/storing-state/</guid><description>If you are developing a web application, sooner or later you will face the problem of saving the local system state for the user.
Imagine you sell elite potatoes over the Internet. The buyer visits the website and enters the search criteria:
strictly from Bolivia or South Africa, harvest of 2022, tuber size from 3 to 7 cm, preferably in the form of a sea seal. The buyer then receives a list of 300 items (seal-shaped potatoes are quite popular in South Africa), split into 6 pages of 50 items each.</description></item><item><title>Good Code Criterion</title><link>https://antonz.org/good-code/</link><pubDate>Wed, 02 Jun 2021 11:00:00 +0000</pubDate><guid>https://antonz.org/good-code/</guid><description>Good code is understandable and non-greedy. Let&amp;rsquo;s talk about it.
Time to understanding The main criterion for good code is the time T it takes for a non-author to understand the code. Not &amp;ldquo;I sorta get it&amp;rdquo;, but understand deep enough to make changes and not break anything.
The smaller the T, the better the code.
Let&amp;rsquo;s say Alice and Bob implemented the same feature, and you want to modify it.</description></item></channel></rss>