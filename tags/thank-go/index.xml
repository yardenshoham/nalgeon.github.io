<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Thank Go! on Anton Zhiyanov</title><link>https://antonz.org/tags/thank-go/</link><description>Recent content in Thank Go! on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 17 Jan 2023 09:20:00 +0000</lastBuildDate><atom:link href="https://antonz.org/tags/thank-go/index.xml" rel="self" type="application/rss+xml"/><item><title>Atomic operations composition in Go</title><link>https://antonz.org/atomics-composition/</link><pubDate>Tue, 17 Jan 2023 09:20:00 +0000</pubDate><guid>https://antonz.org/atomics-composition/</guid><description>An atomic operation in a concurrent program is a great thing. Such operation transforms into a single processor instruction, so it does not require locks. You can safely call it from different goroutines and receive a predictable result.
But what happens if you abuse atomics? Let&amp;rsquo;s figure it out.
Atomicity Let&amp;rsquo;s look at a function that increments a counter:
var counter int32 func increment() { counter += 1 // random sleep up to 10 ms sleep(10) counter += 1 } If we call it 100 times in a single goroutine:</description></item><item><title>Idempotent Close in Go</title><link>https://antonz.org/idempotent-close/</link><pubDate>Wed, 11 Jan 2023 11:00:00 +0000</pubDate><guid>https://antonz.org/idempotent-close/</guid><description>Idempotence is when a repeated call to an operation on an object does not result in changes or errors. Idempotence is a handy development tool.
Let&amp;rsquo;s see how idempotence helps to free the occupied resources safely.
Idempotent Close Suppose we have a gate:
type Gate struct{ // internal state // ... } The NewGate() constructor opens the gate, acquires some system resources, and returns an instance of the Gate.</description></item></channel></rss>