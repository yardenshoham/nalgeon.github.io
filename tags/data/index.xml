<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data on Anton Zhiyanov</title><link>https://antonz.org/tags/data/</link><description>Recent content in Data on Anton Zhiyanov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 03 Jun 2023 15:00:00 +0000</lastBuildDate><atom:link href="https://antonz.org/tags/data/index.xml" rel="self" type="application/rss+xml"/><item><title>Compare with Neighbors in SQL</title><link>https://antonz.org/sql-compare-neighbors/</link><pubDate>Sat, 03 Jun 2023 15:00:00 +0000</pubDate><guid>https://antonz.org/sql-compare-neighbors/</guid><description>This post is part of the &amp;ldquo;SQL Recipes&amp;rdquo; series, where I provide short patterns for solving common SQL data analysis tasks.
Suppose we want to compare each data record with its neighbors based on some column value. For example:
Compare sales from one month to the previous month (month-over-month or MoM change) or to the same month a year ago (year-over-year or YoY change). Compare financial results for a given period to the same period in the previous year (like-for-like or LFL analysis).</description></item><item><title>LIMIT vs. FETCH in SQL</title><link>https://antonz.org/sql-fetch/</link><pubDate>Tue, 30 May 2023 18:00:00 +0000</pubDate><guid>https://antonz.org/sql-fetch/</guid><description>Fun fact: There is no limit clause in the SQL standard.
Everyone uses limit:
select * from employees order by salary desc limit 5; ┌────┬───────┬────────────┬────────┐ │ id │ name │ department │ salary │ ├────┼───────┼────────────┼────────┤ │ 25 │ Frank │ it │ 120 │ │ 23 │ Henry │ it │ 104 │ │ 24 │ Irene │ it │ 104 │ │ 33 │ Alice │ sales │ 100 │ │ 31 │ Cindy │ sales │ 96 │ └────┴───────┴────────────┴────────┘ And yet, according to the standard, we should be using fetch:</description></item><item><title>Segmenting Data in SQL</title><link>https://antonz.org/sql-segmenting/</link><pubDate>Tue, 23 May 2023 15:30:00 +0000</pubDate><guid>https://antonz.org/sql-segmenting/</guid><description>This post is part of the &amp;ldquo;SQL Recipe&amp;rdquo; series, where I provide short patterns for solving common SQL data analysis tasks.
Suppose we want to divide our data into several segments based on the value of one or more columns (e.g., to assign customers or products to different groups for marketing purposes).
The solution is to use the ntile() function over an SQL window ordered by target columns.
Example Let&amp;rsquo;s divide the employees into three groups according to their salary:</description></item><item><title>SQL Cheat Sheet</title><link>https://antonz.org/sql-cheatsheet/</link><pubDate>Sun, 14 May 2023 13:00:00 +0000</pubDate><guid>https://antonz.org/sql-cheatsheet/</guid><description>This is a short cheat sheet for those who were once familiar with SQL selects, but haven&amp;rsquo;t given it much practice since. The examples are interactive, so you can both read and practice.
We will use the toy employees table:
┌────┬───────┬────────┬────────────┬────────┐ │ id │ name │ city │ department │ salary │ ├────┼───────┼────────┼────────────┼────────┤ │ 11 │ Diane │ London │ hr │ 70 │ │ 12 │ Bob │ London │ hr │ 78 │ │ 21 │ Emma │ London │ it │ 84 │ │ 22 │ Grace │ Berlin │ it │ 90 │ │ 23 │ Henry │ London │ it │ 104 │ │ 24 │ Irene │ Berlin │ it │ 104 │ │ 25 │ Frank │ Berlin │ it │ 120 │ │ 31 │ Cindy │ Berlin │ sales │ 96 │ │ 32 │ Dave │ London │ sales │ 96 │ │ 33 │ Alice │ Berlin │ sales │ 100 │ └────┴───────┴────────┴────────────┴────────┘ Basics The basic building blocks of an SQL query.</description></item><item><title>Ranking Records in SQL</title><link>https://antonz.org/sql-ranking/</link><pubDate>Thu, 11 May 2023 15:50:00 +0000</pubDate><guid>https://antonz.org/sql-ranking/</guid><description>This post is part of the &amp;ldquo;SQL Recipe&amp;rdquo; series, where I provide short patterns for solving common SQL data analysis tasks.
Suppose we want to create a ranking, where the position of each record is determined by the value of one or more columns.
The solution is to use the rank() function over an SQL window ordered by target columns.
Example Let&amp;rsquo;s rank employees by salary:
select rank() over w as &amp;#34;rank&amp;#34;, name, department, salary from employees window w as (order by salary desc) order by &amp;#34;rank&amp;#34;, id; The rank() function assigns each employee a rank according to their salary (order by salary desc).</description></item><item><title>Rolling Aggregates with SQL Window Functions</title><link>https://antonz.org/sql-window-functions-rolling-aggregates/</link><pubDate>Mon, 01 May 2023 12:00:00 +0000</pubDate><guid>https://antonz.org/sql-window-functions-rolling-aggregates/</guid><description>This is an excerpt from my book SQL Window Functions Explained. The book is a clear and visual introduction to the topic with lots of practical exercises.
Previously we&amp;rsquo;ve covered ranking, offset and aggregate window functions.
​Rolling aggregates (also known as sliding or moving aggregates) are just totals — sum, average, count etc. But instead of calculating them across all elements, we take a different approach.
Let&amp;rsquo;s look at some examples.</description></item><item><title>Aggregating Data with SQL Window Functions</title><link>https://antonz.org/sql-window-functions-aggregation/</link><pubDate>Sun, 30 Apr 2023 18:30:00 +0000</pubDate><guid>https://antonz.org/sql-window-functions-aggregation/</guid><description>This is an excerpt from my book SQL Window Functions Explained. The book is a clear and visual introduction to the topic with lots of practical exercises.
Previously we&amp;rsquo;ve covered ranking and offset window functions.
Aggregation means counting totals or averages (or other aggregates). For example, the average salary per city. Or the total number of gold medals for each country in the Olympic Games standings.
We will aggregate records from the employees table:</description></item><item><title>Interactive SQL Examples in JavaScript</title><link>https://antonz.org/interactive-sql-examples/</link><pubDate>Sun, 05 Mar 2023 12:00:00 +0000</pubDate><guid>https://antonz.org/interactive-sql-examples/</guid><description>Reading about SQL is fun, but trying out live examples is even better! So I created JavaScript widgets that turn static SQL code in your articles into interactive examples.
Here is a working example. Give it a try:
select * from employees limit 5; And here are the four steps to creating executable SQL examples in your own articles or documentation:
1. Include the widgets You&amp;rsquo;ll need three JavaScript files:</description></item><item><title>Comparing by Offset with SQL Window Functions</title><link>https://antonz.org/sql-window-functions-offset/</link><pubDate>Thu, 16 Feb 2023 14:00:00 +0000</pubDate><guid>https://antonz.org/sql-window-functions-offset/</guid><description>This is an excerpt from my book SQL Window Functions Explained. The book is a clear and visual introduction to the topic with lots of practical exercises.
Previously we&amp;rsquo;ve covered ranking window functions.
Comparing by offset means looking at the difference between neighboring values. For example, if you compare the countries ranked 5th and 6th in the world in terms of GDP, how different are they? What about 1st and 6th?</description></item><item><title>Ranking Data with SQL Window Functions</title><link>https://antonz.org/sql-window-functions-ranking/</link><pubDate>Wed, 08 Feb 2023 13:30:00 +0000</pubDate><guid>https://antonz.org/sql-window-functions-ranking/</guid><description>This is an excerpt from my book SQL Window Functions Explained. The book is a clear and visual introduction to the topic with lots of practical exercises.
Ranking means coming up with all kinds of ratings, from the winners of the World Swimming Championships to the Forbes 500.
We will rank records from the toy employees table:
┌────┬───────┬────────┬────────────┬────────┐ │ id │ name │ city │ department │ salary │ ├────┼───────┼────────┼────────────┼────────┤ │ 11 │ Diane │ London │ hr │ 70 │ │ 12 │ Bob │ London │ hr │ 78 │ │ 21 │ Emma │ London │ it │ 84 │ │ 22 │ Grace │ Berlin │ it │ 90 │ │ 23 │ Henry │ London │ it │ 104 │ │ 24 │ Irene │ Berlin │ it │ 104 │ │ 25 │ Frank │ Berlin │ it │ 120 │ │ 31 │ Cindy │ Berlin │ sales │ 96 │ │ 32 │ Dave │ London │ sales │ 96 │ │ 33 │ Alice │ Berlin │ sales │ 100 │ └────┴───────┴────────┴────────────┴────────┘ playground • download</description></item></channel></rss>